<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Synth</title>
    <script src="qwerty-hancock.js"></script>
</head>
<body>
<div>
<div id="keyboard"></div>
<canvas id="visualizer" width="600" height="150"></canvas>
</div>
<script>
  var keyboard = new QwertyHancock({
      id: 'keyboard',
      startNote: 'A2',
      octaves: 3,
      width: 600,
      height: 150,
  });

  var context = new AudioContext();

  function sawtooth(out) {
	  var osc = context.createOscillator();
	  osc.type = 'sawtooth';
	  osc.frequency.value = 440;
	  osc.start();

	  var env = context.createGain();
	  env.gain.value = 1;
	  osc.connect(env);
	  return {
	  	connect: function(out) {
		    env.connect(out);
		},
		setFrequency: function(frequency, now) { 
		      osc.frequency.linearRampToValueAtTime(frequency, now);
		}
	  };
  }


  var osc1 = sawtooth();
  var osc2 = sawtooth();
  var osc3 = sawtooth();


  var env = context.createGain();
  env.gain.value = 0;

  osc1.connect(env);
  osc2.connect(env);
  osc3.connect(env);

  var analyser = context.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.85;

  var bufferLength = analyser.fftSize;
  var dataArray = new Float32Array(bufferLength);
  var canvas = document.querySelector('#visualizer');
  var canvasCtx = canvas.getContext("2d");
  WIDTH = canvas.width;
  HEIGHT = canvas.height;


  function draw() {
  requestAnimationFrame(draw);
  analyser.getFloatTimeDomainData(dataArray);

  canvasCtx.fillStyle = 'rgb(200, 200, 200)';
  canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
  canvasCtx.lineWidth = 2;
  canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
  canvasCtx.beginPath();

  var sliceWidth = WIDTH * 1.0 / bufferLength;
  var x = 0;

  for(var i = 0; i < bufferLength; i++) {
    var v = dataArray[i] * HEIGHT/4;
    var y = HEIGHT/2 + v;

    if(i === 0) {
      canvasCtx.moveTo(x, y);
    } else {
      canvasCtx.lineTo(x, y);
    }
    x += sliceWidth;
  }

  canvasCtx.lineTo(canvas.width, canvas.height/2);
  canvasCtx.stroke();
  };

  env.connect(analyser);
  analyser.connect(context.destination);

  keyboard.keyDown = function (note, frequency) {
      context.resume().then(function(){
      now = context.currentTime+0.1;
      amp = env.gain.value;
      env.gain.cancelScheduledValues(now);
      env.gain.setValueAtTime(amp, now);

      osc1.setFrequency(frequency, now);
      osc2.setFrequency(frequency*0.25, now);
      osc3.setFrequency(frequency*0.5, now);

      env.gain.linearRampToValueAtTime(1, now);
      })
  };

  keyboard.keyUp = function (node, frequency) {
      now = context.currentTime;
      amp = env.gain.value;

      env.gain.cancelScheduledValues(now);
      env.gain.setValueAtTime(amp, now);

      env.gain.linearRampToValueAtTime(0, now + 0.5);
  }

  canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);
  draw();

  // detune oscillator
  // release / decay properly i.e  aim over then fall down to note

  // wavetable / waveform

  // chorus effect? delay?

  // polyphony
</script> 
</body></html>
